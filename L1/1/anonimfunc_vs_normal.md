[Назад](/L1/L1_.md) 

## передача анонимной структуры vs обычной в поле интерфеса

Анонимная структура - это структура, которая не имеет имени типа и объявляется прямо в месте использования.

- можем передать только конкретную структуру данных, только с разными значениями внутри
- передаем значение

поле интерфеса
- может принимать различные типы данных, главное чтобы они соответствовали интефейсу
- передаем поведение
- позволяет использовать полиморфизм и работать с различными типами структур, не завися от конкретной реализации

-------------------------------------------------
В Go можно передавать анонимные структуры как параметры функций. Анонимная структура - это структура, которая не имеет имени типа и объявляется прямо в месте использования.

Вот пример передачи анонимной структуры в функцию:

go
package main

import "fmt"

func printPersonInfo(person struct {
    name string
    age  int
}) {
    fmt.Printf("Name: %s, Age: %d\n", person.name, person.age)
}

func main() {
    person := struct {
        name string
        age  int
    }{
        name: "John",
        age:  25,
    }

    printPersonInfo(person)
}


В этом примере мы объявляем функцию printPersonInfo, которая принимает аргумент типа анонимной структуры с полями name и age. Затем мы объявляем анонимную структуру в функции main, инициализируем ее значениями и передаем ее в функцию printPersonInfo.

При выполнении кода будет выведено:


Name: John, Age: 25


Таким образом, анонимные структуры позволяют передавать данные без необходимости определения отдельного типа структуры. Они удобны, когда требуется передать небольшой набор данных в функцию или метод.


---------------------------------------------------------
В Go также можно передавать структуры в поле интерфейса. Это позволяет использовать различные типы структур в качестве значения поля интерфейса, что делает код более гибким и расширяемым.

Вот пример передачи структуры в поле интерфейса:

go
package main

import "fmt"

type Animal interface {
    Sound()
}

type Dog struct {
    name string
}

func (d Dog) Sound() {
    fmt.Println("Woof!")
}

type Cat struct {
    name string
}

func (c Cat) Sound() {
    fmt.Println("Meow!")
}

func MakeSound(animal Animal) {
    animal.Sound()
}

func main() {
    dog := Dog{name: "Buddy"}
    cat := Cat{name: "Whiskers"}

    MakeSound(dog)
    MakeSound(cat)
}


В этом примере мы объявляем интерфейс Animal, который имеет метод Sound(). Затем мы определяем две структуры Dog и Cat, которые реализуют этот метод. Функция MakeSound принимает аргумент типа Animal и вызывает его метод Sound(). В функции main мы создаем экземпляры структур Dog и Cat и передаем их в функцию MakeSound.

При выполнении кода будет выведено:


Woof!
Meow!


Таким образом, передача структуры в поле интерфейса позволяет использовать полиморфизм и работать с различными типами структур, не завися от конкретной реализации. Это очень полезно при разработке гибких и расширяемых систем.