# [Назад](/L1/L1_.md)

## Как вызвать конкретный? (*cl1) f1() (cl1) f1()

### Ответ

В рамках одного типа неполучиться реализовать и тот и тот. Нужно сделать композицию.

Допустим есть 2 метода с одним именем но разным получателями, один по значению а другой по указателю.

Создадим структуру в которую будут входить именованные переменные с этими типами.

- Если нам нужен метод по значению вызываем его через свою переменную
- Если нужен метод по указателю вызываем черз другую переменную

-------------------------------------

```go
package main

import "fmt"

type cl1 int
type cl2 int

type cl3 struct {
    value cl1
    point cl2
}

func (c cl1) F() {
    fmt.Println("F by value")
}

func (c *cl2) F() {
    fmt.Println("F by pointer")
}

func main() {
    cl3{}.value.F()
    (&cl3{}).point.F()

}
```

-------------------------------------
Чтобы объединить методы F по значению и по указателю в Go, вы можете создать два метода с одинаковым именем F, но с разными получателями.

Пример кода может выглядеть следующим образом:

```go
package main

import "fmt"

type cl1 struct {
    name string
}

func (c cl1) F() {
    fmt.Println("F by value")
}

func (c *cl1) F() {
    fmt.Println("F by pointer")
}

func main() {
    obj := cl1{name: "Object"}
    obj.F() // Вызывает метод F по значению

    ptr := &obj
    ptr.F() // Вызывает метод F по указателю
}
```

В этом примере мы создали структуру cl1 с двумя методами F. Первый метод F имеет получатель типа cl1, а второй метод F имеет получатель типа *cl1 (указатель на cl1). В функции main мы создали экземпляр obj структуры cl1 и вызвали метод F на этом экземпляре, что вызывает метод F по значению. Затем мы создали указатель ptr на obj и вызвали метод F на этом указателе, что вызывает метод F по указателю.
