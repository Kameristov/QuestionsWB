# [Назад](/L1/L1_.md)

## Перегрузка методов Golang

### Ответ

В Го нет перегрузки методов.

Но можно реализовать похожее поведение, с помощью передачи в метод переменного количества пустых интерфейсов.
Для определения типа входных аргументов использовать `type switch`.
Для прохождения по всем аргументам можно использовать цикл `for range`

```go
type Interface interface{
    Method(x ...interface{})
}

type Data1 struct {
// поля структуры
}

func (d *Data1) Method(x ...interface{}){
for _, val := range(x){
    switch val.(type) {
        case int:
        // действие
        case string:
        // действие
        default:
        // действие
        }
    }
}


type Data2 struct {
// поля структуры
}

func (d *Data2) Method(x ...interface{}){
for _, val := range(x){
    switch val.(type) {
        case int:
        // действие
        case string:
        // действие
        default:
        // действие
        }
    }
}

func main() {
    
}

```

----------------------------------------------------------------
Вместо этого в Go используется концепция методов с одинаковыми именами, но разными типами-получателями, что может напоминать перегрузку методов.

Когда мы определяем метод для типа в Go, мы указываем тип, к которому этот метод будет привязан, с помощью получателя. Получатель выглядит как параметр функции перед именем метода, и он указывает тип, к которому привязан метод.

Вот пример привязки метода `Print` к двум разным типам `Alpha` и `Beta`:

```go
type Alpha struct {
    value int
}

func (a Alpha) Print() {
    fmt.Println("Alpha:", a.value)
}

type Beta struct {
    value string
}

func (b Beta) Print() {
    fmt.Println("Beta:", b.value)
}
```

Здесь у типа `Alpha` есть метод `Print`, который выводит значение поля `value`, и у типа `Beta` тоже есть метод `Print`, но он выводит значение строки `value`.

Теперь можно вызывать метод `Print` для экземпляров значений типов `Alpha` и `Beta`, и Go будет выбирать правильный метод в зависимости от типа получателя:

```go
alpha := Alpha{value: 42}
beta := Beta{value: "hello"}

alpha.Print() // Вывод: Alpha: 42
beta.Print() // Вывод: Beta: hello
```

Таким образом, в Go невозможно напрямую перегрузить методы, но можно достичь подобного эффекта, определяя методы с одинаковыми именами и разными типами-получателями.
