# [Назад](/L1/L1_.md)

## как реализовать FIFO циклом

Нужно использовать канал

--------------------------------------------------------
Простой способ реализовать структуру данных временной очереди в Go - это использовать срез:

- чтобы добавить в очередь, вы используете встроенную функцию append
- чтобы удалить из очереди - срезать первый элемент

```
var queue []string

queue = append(queue, "Hello ") // Добавление в очередь
queue = append(queue, "world!")

for len(queue) > 0 {
    fmt.Print(queue[0]) // Первый элемент
    queue = queue[1:]   // Удаление из очереди
}
```

Вывод:

```Hello world!```

Остерегайтесь утечек памяти
Вы можете удалить первый элемент перед удалением из очереди.

```// Удаление из очереди
queue[0] = "" // Удаляем элемент
              // (записываем нулевое значение)
queue = queue[1:]
```

Предупреждение: память, выделенная для массива, никогда не возвращается. Для долгоживущей очереди вам, вероятно, следует использовать динамическую структуру данных, такую как связанный список.

Связанный список
Пакет container/list реализует двусвязный список, который можно использовать в качестве очереди.

```queue := list.New()

queue.PushBack("Hello ") // Добавление в очередь
queue.PushBack("world!")

for queue.Len() > 0 {
    e := queue.Front() // Первый элемент
    fmt.Print(e.Value)

    queue.Remove(e) // Удаление из очереди
}
```

Вывод:

```Hello world!```

--------------------------------------------------------

Для реализации FIFO (первым пришел, первым обслужен) с использованием цикла в Go применяется структура данных очередь (queue).

Вот пример реализации FIFO с использованием цикла в Go:

```go
package main

import "fmt"

// Структура данных для хранения элементов очереди
type Queue struct {
    items []int
}

// Добавление элемента в очередь
func (q *Queue) Enqueue(item int) {
    q.items = append(q.items, item)
}

// Удаление и возврат первого элемента из очереди
func (q *Queue) Dequeue() int {
    if len(q.items) == 0 {
        return -1 // или любое другое значение, которое сигнализирует об ошибке или пустой очереди
    }
    item := q.items[0]
    q.items = q.items[1:]
    return item
}

func main() {
    q := Queue{}

    // Добавление элементов в очередь
    q.Enqueue(1)
    q.Enqueue(2)
    q.Enqueue(3)

    // Циклическое обслуживание элементов в очереди
    for len(q.items) > 0 {
        item := q.Dequeue()
        fmt.Println("Обслужено:", item)
    }
}
```

В этом примере мы определили структуру данных `Queue` с полем `items`, представляющим массив элементов очереди. Метод `Enqueue` добавляет элемент в конец очереди, а метод `Dequeue` удаляет и возвращает первый элемент из очереди.

Затем мы создали экземпляр `q` структуры `Queue` и добавили несколько элементов в очередь с помощью метода `Enqueue`.

Затем мы использовали цикл `for` для обслуживания элементов в очереди. В каждой итерации цикла мы извлекаем первый элемент из очереди с помощью метода `Dequeue` и выводим его на печать.

Вывод программы:

```
Обслужено: 1
Обслужено: 2
Обслужено: 3
```

В результате, элементы извлекаются из очереди в том порядке, в котором они были добавлены - согласно принципу FIFO.
