 [Назад](/L1/L1_.md) 
## при переносе значений из 1го массива во 2й все значения 2го заполнились последним из 1го

1. В условиях переноса ошибка
2. Использовался цикл for с горутинами без копирования элемента на каждом шаге цикла.



--------------------------------

package main

import (
	"fmt"
	"sync"
)

func main() {
	arr1 := []int{1, 2, 3}
	arr2 := make([]int, 0, len(arr1))
	wg := sync.WaitGroup{}

	for _, val := range arr1 {
		wg.Add(1)
		go func() {
			arr2 = append(arr2, val)
			wg.Done()
		}()

	}
	wg.Wait()
	fmt.Println(arr2)
}




----------------------------------------------------------------
Ситуация, когда все значения второго массива заполнились последним значением из первого массива, могла произойти из-за ошибки в коде копирования значений из одного массива в другой.

Пример кода, который может привести к такой ситуации:

```go
package main

import "fmt"

func main() {
    arr1 := []int{1, 2, 3}
    arr2 := make([]int, len(arr1))

    for i := 0; i < len(arr1); i++ {
        arr2[i] = arr1[len(arr1)-1]
    }

    fmt.Println(arr2)
}
```

В этом коде значения из первого массива `arr1` копируются во второй массив `arr2`. Однако, в цикле `for` используется `arr1[len(arr1)-1]`, что означает, что каждое значение второго массива будет равно последнему значению из первого массива.

Чтобы исправить эту ситуацию и правильно скопировать значения из одного массива в другой, можно использовать индекс `i` вместо `len(arr1)-1`. Вот исправленный пример:

```go
package main

import "fmt"

func main() {
    arr1 := []int{1, 2, 3}
    arr2 := make([]int, len(arr1))

    for i := 0; i < len(arr1); i++ {
        arr2[i] = arr1[i]
    }

    fmt.Println(arr2)
}
```

В этом примере значения из первого массива `arr1` правильно копируются во второй массив `arr2` с использованием индекса `i`. Результат будет `[1, 2, 3]`, а не `[3, 3, 3]`.